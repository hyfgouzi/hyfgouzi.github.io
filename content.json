{"meta":{"title":"gouzi避难所","subtitle":"呵呵","description":"呵呵呵","author":"hyfgouzi","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-04-08T12:39:02.000Z","updated":"2020-04-08T13:21:19.286Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"不知道写啥啊！"},{"title":"分类","date":"2020-04-08T12:14:30.000Z","updated":"2020-04-08T13:17:55.811Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-08T11:56:04.000Z","updated":"2020-04-08T12:42:33.838Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"嵌入式学习笔记3","slug":"嵌入式学习笔记3","date":"2020-04-10T02:59:12.000Z","updated":"2020-04-10T04:02:27.126Z","comments":true,"path":"2020/04/10/嵌入式学习笔记3/","link":"","permalink":"http://yoursite.com/2020/04/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/","excerpt":"","text":"刚开始写C和ARM混合编程的时候，我的内心是崩溃的，感觉无从下手，在网上搜了很多资料，零零散散的，仍然没有解决我的问题。后来终于写出来了一道很简单的C和ARM混合编程，我更崩溃了。它确实没有什么难度，但它有着学习所有知识的共同点：不知道怎么学。解决问题，首先得知道，问题是什么。很多时候不知道怎么办，糊里糊涂的一顿操作，终于碰巧遇到了对自己有用的，却发现时间已过大半。这很糟糕。遇到问题时，必须清楚自己的问题是什么，将它具体的表达出来，然后逐一解决。 混合编程：请用ARM汇编与c语言混合编程实现字符串比较功能（c程序调汇编程序），汇编程序负责比较两个字符串，c程序负责赋值两个串及输出比较结果。 这是一道很简单的题目，ARM汇编与c语言混合编程有多种形式,(c程序调用混编)是其中一种，有一些需要注意的地方(会在下面提出) 看到一道题目，首先把自己会的那部分写出： c程序负责复制两个串及输出比较结果： 1234567891011121314151617 #include&lt;stdio.h&gt;#include &lt;LPC21xx.H&gt; &#x2F;&#x2F;uvision c调ARM汇编配置文件##############int main()&#123; char *a&#x3D;&quot;azzz&quot;; char *b&#x3D;&quot;aczz&quot;; PINSEL0 &#x3D; 0x00050000; &#x2F;* Enable RxD1 and TxD1 *&#x2F; U1LCR &#x3D; 0x83; &#x2F;* 8 bits, no Parity, 1 Stop bit *&#x2F; U1DLL &#x3D; 97; &#x2F;* 9600 Baud Rate @ 15MHz VPB Clock *&#x2F; U1LCR &#x3D; 0x03; ####### ####### printf(&quot;字符串相等\\n&quot;); ####### printf(&quot;字符串不相等\\n&quot;); return 0;&#125; 如上只是个简单的C语言的赋值和输出代码，7-10行代码为串口输出代码，即在串口2中输出（字符串相等或者不相等)，########是需要写代码的部分。既然是调用ARM汇编，很好理解，就是ARM汇编里有着比较的方法，C语言调用了这个方法。即跟C语言里调用函数一样，只不过这个函数是在外部文件里。在汇编程序中使用EXPORT指示符声明本程序可以被别的程序调用。在C语言程序中使用extern关键词声明该汇编程序可以被调用。extern int SCompare(char *a,char *b);这条语句指明了在C语言中可以调用汇编中的SCompare。函数离不开参数和返回值，那么传参是一个问题，在参数传递的时候我曾纠结了好久，但大可不必，C的函数参数会自动存在R0,R1,R2,R3中，如果参数多于4个，多余参数存放在堆栈当中。很好理解，就把它当做函数里的形参，实参。传递到汇编中，(想想在C里你会怎么做?),定义两个变量接受参数的值。LDRB R3,[R1],#1LDRB R4,[R0],#1这两条代码，就把r0,r1中的字符串依次传递给了r3,r4。数据传递后，进行比较CMP R3,R4比较的结果有两种，一样或者不一样，因此，需要对两个结果分别作出限制。（想想在C里你会怎么做?)if…else…如果一样，那么XXXX，否则在汇编中，没有if..else…语句，但是可以用条件限制指令，比较完后可以利用B/BNE等 进行跳转，（嵌入式学习笔记2中有)。因此，在CMP语句下面接上一个BNE语句，如果不相等，就跳转。如果相等，继续比较。CMP和BNE连用，完美的解决了问题。比较完后，(想想在C里你会怎么做)，如果一样，会赋一个值，如果不一样，会赋一个值。通过MOV即可完成。但这里有一个坑，我想你必须知道，C向ARM传递参数的时候，将参数存到R0,R1,R2,R3中，但返回参数是存在R0中，你如果写成了R3，那肯定是不会对的。MOV PC,LR这很重要，有了它，就可将值返回给C代码。既然有了返回值，那么在C里需要接受它int flagflag=SCompare(a,b)flag中就存储了代表一样或者不一样的值。在C中，利用if…else…即可完成实现。完整代码如下： 123456789101112131415161718#include&lt;stdio.h&gt;#include &lt;LPC21xx.H&gt;extern int SCompare(char *a,char *b);int main()&#123; char *a&#x3D;&quot;azzz&quot;; char *b&#x3D;&quot;aczz&quot;; int flag; PINSEL0 &#x3D; 0x00050000; &#x2F;* Enable RxD1 and TxD1 *&#x2F; U1LCR &#x3D; 0x83; &#x2F;* 8 bits, no Parity, 1 Stop bit *&#x2F; U1DLL &#x3D; 97; &#x2F;* 9600 Baud Rate @ 15MHz VPB Clock *&#x2F; U1LCR &#x3D; 0x03; flag&#x3D;SCompare(a,b); if(flag) printf(&quot;字符串相等\\n&quot;); else printf(&quot;字符串不相等\\n&quot;); return 0;&#125; 1234567891011121314151617AREA SCompare,CODE,READONLY EXPORT SCompareSTR LDRB R3,[R1],#1 LDRB R4,[R0],#1 CMP R3,R4 BNE NO CMP R3,#0 BNE STRYES MOV R0,#1 B ENDCMPNO MOV R0,#0ENDCMP MOV PC,LR END","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"嵌入式学习笔记2","slug":"嵌入式学习笔记2","date":"2020-04-09T09:08:34.000Z","updated":"2020-04-09T10:29:47.603Z","comments":true,"path":"2020/04/09/嵌入式学习笔记2/","link":"","permalink":"http://yoursite.com/2020/04/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","excerpt":"","text":"ARM体系结构指令集CPU指令集是软、硬件之间的一个重要分界线，指令集向上要很好地支持编译器，向下要方便硬件的设计实现。ARM处理器有三个指令集:32位的ARM指令集，16位的Thumb指令集和8位的Jazelle其中: ARM指令集是主要指令集，程序启东市总是从32位ARM指令集开始，并且所有的异常中断都自动切换为ARM指令状态。 Thumb指令是压缩的指令，读取指令之后先动态解压缩，然后作为标准的ARM指令执行。 Jazelle是Java字节码指令集，它能加快Java代码的执行速度 ARM处理器的寻址方式寄存器寻址、立即数寻址、寄存器移位寻址、寄存器间接寻址、基址寻址、多寄存器寻址、栈寻址、块拷贝寻址和相对寻址。 寄存器寻址指令中地址码给出的是寄存器编号，在该寄存器中存放的是操作数，可以直接用于运算。由于寄存器寻址执行效率高，因此ARM指令普遍采用此种寻址方式。例如：ADD R0,R3,R4R0&lt;-R3+R4 立即数寻址指令的地址码字段存放的不是操作数地址，而是操作数本身。立即数寻址的特点是速度快。但缺点是取值受到限制。通常使用的立即数是12位或者8位的。例如：AND R3,R7,#&amp;FF在该指令中，第3个操作数是一个立即数，以”#”为前缀。如果在”#”后加”&amp;”表示十六进制数。这条AND操作指令的功能是先将R7中的32位数与0xFF进行与运算，将结果送到R3寄存器。 寄存器移位寻址这种寻址方式是ARM指令集特有的。在参与第一个操作数运算之前，第2个寄存器操作数可以有选择地进行移位操作。例如:ADD R3,R2,R1,LSL #3R3&lt;-R2+R1*8这条指令表示寄存器R1的内容逻辑左移3位，再与寄存器R2内容相加，结果放入R3中。（逻辑右移LSR） 寄存器间接寻址指令的地址码字段给出某一通用寄存器编号。在该寄存器中存放操作数的有效地址，而操作数则存放在存储单元（内存）中，即寄存器为操作数的地址指针。例如：LDR R0,[R1]R0&lt;-[R1]STR R0,[R1]R0-&gt;[R1] 多寄存器寻址一次可以传送几个寄存器的值。一条指令可以传送16个寄存器的任何子集（或所有16个寄存器）。例如：LDMIA R3!,{R0,R2,R6}R0&lt;-[R3],R2&lt;-[R3+4],R6&lt;-[R3+8]由于传送的数据项总是32位的字，基址寄存器R3应当字对准，这条指令将R3指向的连续存储单元的内容装载到寄存器R0、R2和R6。 块拷贝寻址指把一块数据从寄存器的某一位置拷贝到另一位置的寻址方式。由于块拷贝操作借助多寄存器传送指令LDM/STM完成，因此从本质上讲，块拷贝寻址就是多寄存器寻址。栈寻址也属于多寄存器寻址。例如，下面两条指令是把寄存器R2~R9中的8个字从R0指向的位置拷贝到R1指向的位置。LDMIA R0!,{R2-R9}STMIA R1!,{R2-R9} 相对寻址以程序计数器PC为基础寄存器，主要用于跳转：例如: 12345 BL SUBR ...SUBR MOV R1,R2 MOV PC,R14 ARM和C混合编程典型的ARM汇编 符号：用于代表某个常量或者标号等 类似于高级语言的标识符 常量：数字：#25，#0x2c 字符，字符串：&apos;a&apos;,&quot;abcd&quot; 布尔常量：{true}，{false} 标号地址标号 段内标号 段外标号 局部标号 ARM汇编语言程序规范 可以在汇编程序中加上空白行，来增加程序的可读性。 指令，指示符，伪指令前必须加空格或者Tab制表符。 所有标号必须在一行的最左边的位置开始书写，标号的后面不要加”:”. 指令、指示符、寄存器名可以用小写字母也可以用大写字母来表示，但不能大小写字母混用。 当一行写不下时，可以用反斜线”&quot;作为这一行最后的符号，然后另起一行接下去写。 分号”;”除非在字符串常量中出现，否则它的出现就表示着注释的开始，此注释直至行尾结束。 ARM汇编语言指示符ARM汇编语言指示符相当于x86处理器语言程序中的伪指令，它与ARM机器指令不存在一一对应的关系，它指示汇编器在汇编目标代码时进行变量定义、存储单元分配等操作。常用伪指令AREA—用于定义一个代码段ENTRY—指定汇编程序的入口点EXPORT—定义一个全局（外部）标号，在本文件中定义，可能在其他文件中引用EQU—类似于C语言的defineCODE16&amp;CODE32ENDARM汇编语言程序举例 12345678910111213 AREA FUNCSUM,CODE,READONLY EXPORT Reset_Handler ;连接器指定要求的程序入口Reset_Handler ;定义程序入口 MOV R0,#1 ;原程序非独立执行 MOV R1,#100 ;为可执行，为r0r1赋值 MOV R4,#0LOOP ADD R4, R4, R0 ;R4为累加器 ADD R0, R0,#1 ;R0增量操作 CMP R0, R1 BLE LOOP ;循环执行 MOV R0, R4 END 以上程序实现了1到100的求和，返回值存到R0中。注意条件指令： BEQ 相等 BNE 不等 BPL 非负 BMI 负 BCC 无进位 BCS 有进位 BLO 小于（无符号数） BHS 大于等于（无符号数） BHI 大于（无符号数） BLS 小于等于（无符号数） BVC 无溢出（有符号数） BVS 有溢出（有符号数） BGT 大于（有符号数） BGE 大于等于（有符号数） BLT 小于（有符号数） BLE 小于等于（有符号数） ARM汇编、C和C++混合编程在C/C++程序中，如果必须使用汇编指令来完成某些操作，可以采用两种方法: 采用内嵌汇编，即在C／C++源程序中嵌人一块汇编代码，让这块汇编代码来完成特定操作。 将必须使用汇编代码的部分独立编写，放在一个文件中，形成一个子程序。C／C++程序可以调用这些汇编程序来完成特定的操作。 C程序中内嵌汇编指令示例：12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;void ex_strcpy(char *src,const char *dst)&#123; int ch; __asm &#123;LOOP: LDRB ch,[src],#1 STRB ch,[dst],#1 CMP ch,#0 BNE LOOP &#125;&#125;int main()&#123;const char *a&#x3D;&quot;this is a c program&quot;;char b[30];__asm&#123; MOV r0,a MOV r1,b BL ex_strcpy,&#123;r0,r1&#125;&#125;printf(&quot;original string : %s\\n&quot;,a);printf(&quot;copied string : %s\\n&quot;,b);return 0;&#125; C/C++与汇编程序的相互调用在汇编程序中使用EXPORT指示符声明本程序可以被别的程序调用。在C语言程序中使用extern关键词声明该汇编程序可以被调用，C++语言程序使用extern“C”来声明该汇编程序可以被调用。C程序保存为.c文件,汇编程序保存为.s文件C语言如同调用函数一样使用汇编程序，函数参数通过R0,R1,R2,R3进行传递，返回值放在R0,R1里。如：strtest.c 123456789101112131415#include &lt;stdio.h&gt; #include &lt;LPC21xx.H&gt; extern void STRCopy(char* d, const char * s);int main (void) &#123; const char * srcstr&#x3D;&quot;first string - source&quot;; char * dststr&#x3D;&quot;second string - dest&quot;; printf(&quot;before copying...\\n&quot;); printf(&quot;%s\\n%s\\n&quot;,srcstr,dststr); STRCopy(dststr,srcstr); printf(&quot;after copying...\\n&quot;); printf(&quot;%s\\n%s\\n&quot;,srcstr,dststr); return 0;&#125; scopy.s 12345678910AREA SCopy,CODE,READONLY EXPORT STRCopySTRCopy LDRB R2,[R1],#1 STRB R2,[R0],#1 CMP R2,#0 BNE STRCopy MOV R7,#100 MOV PC,LR END 汇编调用C在汇编程序中使用IMPORT指示符声明将要调用C程序。采用B/BL跳转实现调用。C程序保存为.c文件,汇编程序保存为.s文件通过R0,R1,R2,R3进行函数参数传递，返回值放在R0,R1里。例如：test_func.c 1234int g(int a,int b,int c, int d,int e)&#123;return a+b+c+d+e;&#125; main_test.s 1234567891011121314151617PRESERVE8 ;EXPORT f AREA f,CODE,READONLY EXPORT Reset_Handler IMPORT gReset_Handler STR LR,[SP,#-4]! MOV R0,#2 ADD R1,R0,R0 ADD R2,R1,R0 ADD R3,R2,R1 STR R3,[SP,#-4]! ADD R3,R1,R1 BL g ADD SP,SP,#4 LDR PC,[SP],#4 END","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"嵌入式学习笔记1","slug":"嵌入式学习笔记1","date":"2020-04-09T08:36:25.000Z","updated":"2020-04-09T09:02:56.791Z","comments":true,"path":"2020/04/09/嵌入式学习笔记1/","link":"","permalink":"http://yoursite.com/2020/04/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"ARM处理器的结构ARM处理器的基本特征: RISC 双密度指令集(支持Thumb指令) 流水线结构 哈佛结构ARM处理器的RSIC特征：CISC–复杂指令集计算机:为实现复杂操作，微处理器提供机器指令，还通过存于只读存贮器（ROM）中的微程序来实现其极强的功能，微处理器在分析每一条指令之后执行微指令来完成所需的功能，这种设计的形式被称为CISC （Complex Instruction Set Computer，复杂指令集计算机）结构。一般CISC计算机所含的指令数目至少300条以上，有的甚至超过500条。RISC–精简指令集计算机:指令系统应当只包含那些使用频率很高的少量指令，并提供一些必要的指令以支持操作系统和高级语言，按照这个原则发展而成的计算机被称为RISC (Reduced Instruction Set Computer，精简指令集计算机)结构。ARM处理器沿用了RISC技术的基本特征。采用指令流水线，采用更多的通用寄存器，只有Load和Store指令能够访问内存，芯片逻辑不采用微指令技术而采用硬布线技术实现，按照正交指令集格式来设计运算指令和数据传送指令。ARM7流水线 ARM7TDMI使用流水线以提高处理器指令的流动速度。流水线允许几个操作同时进行，以及处理和存储系统连续操作。 ARM7TDMI使用3级流水线，因此，指令的执行分3个阶段:取指，译码和执行。 正常操作执行：在执行当前一条指令的同时，后续的一条指令被译码，后续的第二条指令从存储器中被取出。 ARM存储器介绍ARM处理器总共有37个32位寄存器，其中有31个通用寄存器、6个状态寄存器（到目前位置状态寄存器只定义了12位）。这些寄存器按照工作模式分成不同的组。编程时哪些寄存器组可用，哪些寄存器组不可用是由处理器的状态和模式决定的。其中: 未分组的通用寄存器寄存器R0～R7为未分组的通用寄存器，它们在任何处理器模式都对应于相同的32位物理寄存器。 第一类分组的通用寄存器寄存器R8~R12有两个分组的物理寄存器。一个用于除FIQ模式之外的所有寄存器模式，另一个用于FIQ模式。在发生FIQ中断后，处理器不必为保护寄存器而浪费时间，从而加速了FIQ的处理速度。（FIQ:快速中断请求，在ARM中，FIQ模式是特权模式中的一种同时也属于异常模式一类。用于高速数据传输或通道处理，在触发快速中断请求（FIQ）时进入。） 第二类分组的通用寄存器寄存器R13,R14分别有6个分组的物理寄存器。一个用于用户和系统模式，其余5个分别用于5种异常模式。 状态寄存器存储器CPSR为当前程序状态存储器，在异常模式中，另外一个寄存器”程序状态保存寄存器(SPSR)”可以被访问。每种异常都有自己的SPSR,在进入异常时它保存CPSR的当前值，异常退出时可通过它恢复CPSR。 哈佛结构冯●诺依曼体系结构 只有一个主存储器，主存储器里存放的内容可以是数据，也可以是指令。它只有一种访问主存储器的指令，并且只有在取指令周期从主存储器取出来的二进制数码才是机器指令。CPU通过数据总线与存储器交换信息。哈佛体系结构体系结构 存储器分为两个部分，一部分存放指令，另一部分存放数据，它们各自拥有自己的地址空间和访问指令，可以分别独立访问。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Markdown基本语法","slug":"我的第一篇博客文章","date":"2020-04-07T09:39:20.000Z","updated":"2020-04-09T07:17:45.484Z","comments":true,"path":"2020/04/07/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/04/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 以下是Markdown基本语法:一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，最多有六级标题，其标准语法一般为在#后+空格再写文字（可达到生成Word目录一样的效果）示例： 123456# 这是一级标题 ## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下: 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体●加粗将加粗的文字左右分别用两个*号包起来 ●斜体将要倾斜的文字左右分别用一个*号包起来 ●斜体加粗将要倾斜和加粗的文字左右分别用三个*号包起来 ●删除线将要加删除线的文字左右分别用两个~~包起来示例: 1234**我是加粗的文字***我是倾斜的文字*&#96;***我是斜体加粗的文字***~~我是加删除线的文字~~ 效果如下:我是加粗的文字我是倾斜的文字`我是斜体加粗的文字我是加删除线的文字 三、引用在引用的文字前加&gt;。引用可以嵌套。示例: 123&gt;我是引用的内容&gt;&gt;我是引用的内容&gt;&gt;&gt;我是引用的内容 效果如下: 我是引用的内容 我是引用的内容 我是引用的内容 四、分割线三个或者三个以上的-或者*示例： 1234-------******* 效果如下： 五、照片添加照片的语法: 1![图片name](图片url &quot;图片title&quot;) 图片name是显示在图片下面的文字，图片url为图片的地址(如果是本地的则对应本地的路径)，图片title是图片的标题，当鼠标移动到上边时显示的内容。title可加可不加。示例： 1![gouzi](https:&#x2F;&#x2F;image.baidu.com&#x2F;search&#x2F;detail?ct&#x3D;503316480&amp;z&#x3D;0&amp;ipn&#x3D;d&amp;word&#x3D;%E7%8B%97%E5%AD%90&amp;hs&#x3D;2&amp;pn&#x3D;2&amp;spn&#x3D;0&amp;di&#x3D;24860&amp;pi&#x3D;0&amp;rn&#x3D;1&amp;tn&#x3D;baiduimagedetail&amp;is&#x3D;0%2C0&amp;ie&#x3D;utf-8&amp;oe&#x3D;utf-8&amp;cl&#x3D;2&amp;lm&#x3D;-1&amp;cs&#x3D;2745431744%2C1432003980&amp;os&#x3D;2651982887%2C4236603102&amp;simid&#x3D;4166058702%2C479116783&amp;adpicid&#x3D;0&amp;lpn&#x3D;0&amp;ln&#x3D;30&amp;fr&#x3D;ala&amp;fm&#x3D;&amp;sme&#x3D;&amp;cg&#x3D;&amp;bdtype&#x3D;0&amp;oriquery&#x3D;%E7%8B%97%E5%AD%90&amp;objurl&#x3D;http%3A%2F%2Fn.sinaimg.cn%2Fsinacn13%2F429%2Fw640h589%2F20180611%2F53ab-hcufqif9221154.jpg&amp;fromurl&#x3D;ippr_z2C%24qAzdH3FAzdH3Fh_z%26e3Bftgw_z%26e3Bv54_z%26e3BvgAzdH3Fw6ptvsj_m9ddnc00l0_80jv1m0dcaa8aa0olz_z%26e3Bip4s&amp;gsm&#x3D;3&amp;islist&#x3D;&amp;querylist&#x3D; &quot;狗子&quot;) 效果如下: 六、超链接超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例: 1[百度](http:&#x2F;&#x2F;baidu.com) 效果如下：百度 七、列表无序列表语法：无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下: 列表内容 列表内容 列表内容 有序列表语法:数字加点 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果如下: 列表内容 列表内容 列表内容 列表嵌套上一级和下一级之间敲三个空格 12345678- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容-一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 效果如下： 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容八、表格语法：123456789|表头|表头|表头||---|:--:|---:|内容|内容|内容|||内容|内容|内容|-两边加：表示文字居中-右边加：表示文字居右第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左 示例：12345名称|叫声|特点--|:--:|--:小猫|喵喵|可爱小狗|旺旺|萌小猪|哼哼|懒 效果如下： 名称 叫声 特点 小猫 喵喵 可爱 小狗 旺旺 萌 小猪 哼哼 懒 九、代码语法：单行代码：代码之间分别用一个反引号包起来（即Esc下面的键) 1&#96;代码内容&#96; 代码块：代码之间分别用三个反引号包起来 123456(&#96;&#96;&#96;)int a,b;a&#x3D;1;b&#x3D;1;int c&#x3D;a+b;(&#96;&#96;&#96;) 注意：实际写时应去掉(),此处是为了防止转译效果如下：单行代码:printf(&quot;hahahaha&quot;);代码块: 1234int a,b;a&#x3D;1;b&#x3D;1;int c&#x3D;a+b; 十、流程图12345678st&#x3D;&gt;start: 开始op&#x3D;&gt;operation: My Operationcond&#x3D;&gt;condition: Yes or No?e&#x3D;&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 本文摘自https://www.jianshu.com/p/191d1e21f7ed作者:高鸿翔","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-07T09:19:22.924Z","updated":"2020-04-08T13:19:11.522Z","comments":true,"path":"2020/04/07/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"},{"name":"learn","slug":"study/learn","permalink":"http://yoursite.com/categories/study/learn/"}],"tags":[{"name":"helloworld","slug":"helloworld","permalink":"http://yoursite.com/tags/helloworld/"},{"name":"博客创建","slug":"博客创建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/"}]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"},{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"},{"name":"learn","slug":"study/learn","permalink":"http://yoursite.com/categories/study/learn/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"},{"name":"helloworld","slug":"helloworld","permalink":"http://yoursite.com/tags/helloworld/"},{"name":"博客创建","slug":"博客创建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/"}]}